### c pointer study

#### 00 

* 变量被保存在内存的 ‘某个地方’。

* 为了标记变量在内存中的具体位置，C语言在内存
  中给这些场所分配了编号(地址)。
  
* `在大多数运行环境中`， 所谓‘指针变量’就是保存变量地址
  的变量。

* `指针就是地址`，不一定全部成立。

>思考 <br>
    * 在引用数组中的元素时，其实a[i] 中的 [] 和数组毫无关系。<br>
    * C里面不存在多维数组


#### 01

> 发现问题的真正所在 <br>
> 不要急于寻找问题的答案，而是应该先去考虑当前的问题是什么


C 语言

* 为了解决眼前问题，由开发现场的人发明的

* 虽然使用方便

* 但看上去不怎么顺眼

* 如果不熟悉的人糊里糊涂的使用了它，难免会带来‘悲剧’的语言


##### 01.1 C 的发展历程

C 原本是为了开发 UNIX 操作系统而设计的语言

* 最早的 UNIX是用汇编来写的

* UNIX 的开发者KenTompson开发了一种称为‘B’的语言。 <br>
    B语言不是直接生成机器码，而是由编译器生成栈式 <br>
    机(Stack Machine)用的中间码，中间码通过解析器执行。

* 在1971年， Ken Tompson的同事Dennis Ritchie 对B <br>
    语言做了改良，追加了char数据类型，并且让B 语言 <br>
    可以直接生成PDP-11的机器码。<br>

    在一段时间内，称改良的B语言为NB( New B),
    之后改称为C 语言。

##### 01.1.6 C的理念

+ 请信任程序员(Trust the promgrammer)

+ 不要阻止程序员去做需要做的工作 (Don't prevent the promgrammer from doing what needs to done)

+ 保持语言的小巧和简单(Keep the language small and simple)

+ 为每一种操作只提供一种方法 (Provide only way to do an operation)

+ 就算不能保证可移植性，也要追求运行效率(Make it fast, even if it is not guaranteed to be portable)



##### 01.2 关于指针

    指针是一种保存变量的地址的变量


##### 01.2.1 指针类型

    指针类型(pointer type) 可由函数类型，对象类型或不完全的
    类型派生， 派生指针类型的类型称为引用类型。

    由引用类型T 派生的指针类型有时称为“指向T的指针”。


    指针类型 和 int类型等类型一样，都是数据类型，
    也存在某类型的变量 和 某类型的值。


    先有“指针类型” 
    才有指针类型的变量 和 指针类型的值
    不同的是，指针类型的值是某个变量的地址。

    code: 1_1_pointer.c

##### 01.2.1 指针操作符

    对变量使用 & 运算符，可以取得该变量的地址。(取址符)
    对指针变量使用 *运算符，等同于它指向的变量。(解引用，顺藤摸瓜)




##### 01.2.2 指针和地址的微妙关系

    几乎所有的处理程序中，所谓的“指针类型的值”，
    实际是指内存的地址。

    1. 指针类型和int类型应该是一回事？

        在C语言的前身B语言中，指针和整数是没有区别的。

        但在很多的运行环境中，init类型和指针类型的长度并不相同
        如MS-DOS中，是通过将16位的值分成两组来表示20位的地址的。


    2. 指针就是地址，指向int的指针也好，指向double的指针也好，
        有必要区别它们吗？

        对大部分的运行环境来说，当程序运行时，不管是指向int的指针
        还是指向double的指针，都保持相同的表现形式。

        但是，仅仅告诉内存地址，却没有告知在那个地址上保存的数据
        类型，是不能取出值的。

        同时指针类型的运算与所指向的数据类型有关，
        指针加N， 指针前进 “当前指针指向的数据类型的长度 * N”

        code: 1_2_pointer_calc.c


    3. 指针就是地址，给指针加 1，指针难道不应该前进1个字节吗？


##### 01.2.3 空指针

    空指针是指可以确保没有指向任何一个对象的地址。

    通常使用宏定义NULL 来表示空指针常量值

    通常根据指针指向的类型来明确区别指针的类型。

    如将‘指向int的指针’ 赋值给 ‘指向double的指针’，编译器
    一般会提示警告。

    但是， 只有NULL, 无论对方指向什么类型的变量，都可以被
    赋值和比较。


    NULL 、 0 和 '\0'

    在C标准中， 空字符的定义为： 所有的位为0 字节称为空字符 (null character)
    空字符在表现上通常使用 '\0', 实际上它等同于 0。

    习惯使然，一般 常量0字符写成 '\0'

    在有的环境中，NULL定义为：
    #define NULL    0

    在大多环境中， 空指针就是为0的地址。
    但是由于硬件的原因， 世上也存在指不为0的空指针。

    使用memset() 和 calloc() 将内存区域清零，其实就是单纯地使用0来填充位。

    在C语言中， ‘当常量0 处于应该作为指针使用的上下文中时，、
        它就是作为空指针使用’。
    如：int *p = 0;
    此时0作为空指针使用


    在一些环境中，有这样定义NULL：
    #define NULL    ((void *)0)

    ANSIC中， 根据‘应该将0作为指针进行处理的上下文’的原则，
    此处显示将0强制转型成 void *是没有意义的。


##### 01.2.4 指针和数组的微妙关系

    给指针加 N，指针前进”当前指针指向的变量类型长度 * N “
    因此，给指向数组的某个元素的指针加 N后，指针会指向N个之后的元素

    表达式中，数组可以解读成 "指向它的初始元素的指针"

    p[i] 是 *(p + i)的简便写法 (语法糖)

```c
# include <stdio.h>
int main(void) {
    int array[5];
    int *p;
    int i;

    // 赋值
    for(i = 0; i < 5; i++) {
        array[i] = i;
    }

    // 输出
    for(p = &array[0]; p != &array[5]; p++) {
        printf("%d \n", *p);
    }

    // 改写 1
    for(i = 0; i < 5; i++) {
        printf("%d \n", *(p+i));
    }

    // 改写 2
    p = array;
    for(i = 0; i < 5; i++) {
        printf("%d \n", *(p+i));
    }


    // 改写 3
    p = array;
    for(i = 0; i < 5; i++) {
        printf("%d \n", p[i]);
    }

    return 0;
}

```

+ 下标运算符[] 和数组是没有关系的
    
    a 将指针 指向数组的初始元素，可以写成：<br>
        p = &array[0];      <br>
    或   <br>
        p = array;          <br><br>

    b 指向数组的解引用，可以写成: <br>
        \*(p + i)            <br>
    或   <br>
        p[ i ]                <br>
    或   <br>
        \*(i + p)            <br>
    或   <br>
        ** i[ p ] **            <br><br>

+ 运算符[] 与数组
    
    a 在数组声明中,[]运算符 表达数组的意思。 <br><br>

    b 在表达式中，无论加不加[]， 数组都可以被解读成指针。 <br><br>


##### 01.2.5 奇怪的指针运算

    B 是一种“没有类型”的语言。 B中可以使用的类型只有word(即整型)，
    指针也是作为整型来使用的。
    B是虚拟机上运行的解析器，这个虚拟机以word为单位分配内存地址。

    由于B以word为单位，如果指针加1，指针就指向数组的下一个元素。

    为了继承这种特性，C引入了 ’指针加1， 指针前进它所指向类型的长度‘这个规则。


    一般情况下，使用指针的程序比较高效。

    对于现在一般成C编译器，无论使用数组还是指针，效率上都
    不会出现明显的差距。基本上都是输出完全相同的机器码。



##### 01.2.6 数组作为函数的参数进行传递

    如果将数组作为函数的参数进行传递，那就传递指向初始元素的指针。

    如果将数组进行值传递时，建议将数组整体整理成结构体成员。

    只有在声明函数形参时，数组的声明才可以解读成指针。

    下面声明的形参，都具有相同的意义：
    int func(int *a)    
    int func(int a[])
    int func(int a[10])
    写法2和写法3是写法1的语法糖。




----

#### 02 C 与内存

    在标准中，’作用域(scope)‘ 和 ’连接(linkage)‘

    用语句块包围的作用域

    static和extern 分别控制静态连接和外部连接。

    全局变量，作用域指文件作用域，连接指外部连接。

##### 02.2.2 C的变量的种类

    作用域

+ 全局变量

    在函数之外声明的变量，默认地成为全局变量。 <br>
    全局变量在任何地方都是可见的。 <br>

    当程序被分割为多个源代码文件进行编译时，声明全局变量的变量 <br>
    也是可以从其他源代码文件中引用的。


+ 文件内部的静态变量

    就算对于像全局变量那样被定义在函数外的变量，<br>
    一旦添加了 static,作用域就只限定在当前所在的源代码文件中。<br>


+ 局部变量

    局部变量是指在函数中声明的变量。<br>
    局部变量只能在包含它的声明语句块中被引用。


>   存储期(storage duration)

+ 静态存储期(static storage duration)
    
    全局变量、文件内的static 变量，指定static 的局部
    变量都持有 静态存储期。

    这些变量统称为静态变量。

    持有静态存储期的变量的寿命从程序运行开始，到程序关闭时结束。

+ 自动存储期( auto stoage duration)

    没有指定static的局部变量，持有自动存储期。

    这样的变量被称为自动变量。

    持有自动存储期的变量，在程序运行进入它所在的语句块时
    被分配以内存区域，该语句块执行结束后这片内存区域被释放。


>在C中有三种内存区域的寿命

1. 静态变量
    寿命从程序运行开始，到程序关闭结束。

2. 自动变量
    寿命 到声明该变量的语句块被执行结束为止。

3. 通过 malloc分配的区域
    寿命到调用 free() 为止。

    code: 2_2_print_address.c
